<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon.jpg?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon.jpg?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="数据结构与算法                           算法分析                           时间复杂度分析       测试  随着输入规模的增大，算法的常数操作可以忽略不计 随着输入规模的增大，与最高次项相乘的常数可以忽略不计 最高次项的指数大的，随着n的增长，结果也会变得增长特别快 算法函数中n最高次幂越小，算法">
<meta property="og:type" content="article">
<meta property="og:title" content="初识数据结构与算法">
<meta property="og:url" content="https://supebam.github.io/2022/04/16/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="supeBam&#96;Blog">
<meta property="og:description" content="数据结构与算法                           算法分析                           时间复杂度分析       测试  随着输入规模的增大，算法的常数操作可以忽略不计 随着输入规模的增大，与最高次项相乘的常数可以忽略不计 最高次项的指数大的，随着n的增长，结果也会变得增长特别快 算法函数中n最高次幂越小，算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607161920925-1623205282384.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607164814276.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607164943394.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133342135.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133328051.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133302789.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608135000407-1623205214916.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608150304875.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608161637374-1623205238081.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608170310300.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608171407017-1623205254540.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610102616158.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610104253725.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610110245937.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610110258691.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610122212921.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610133228809.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610154053255.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610154740683.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610175504457.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611092534329.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611095913141.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104159340.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104246540.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104314776.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611142912885.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611145246660.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611155437540.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611172719602.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611172817988.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210612165830727.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210612165847273.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613093509772.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105501688.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105552102.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105630696.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112410494.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112615828.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112721103.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112813302.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112858049.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112930532.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113038613.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113118592.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113213757.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145651921.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145757679.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145950939.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613150028180.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613161810368.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613164915974.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165133876.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165144822.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165214463.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165247569.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165434398.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084304098.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084324958.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084536493.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084458710.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614094622616.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084615401.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084624978.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614094541050.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614095244785.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100701610.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100730351.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100858414.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100930467.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614101930119.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614102001236.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614151349050.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614151429465.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192345755.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192515122.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192549752.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615093211138.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100708182.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100722311.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100757487.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100841745.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100916768.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100927136.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104208108.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104220502.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104238387.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615112619545.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615113855769.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615113926655.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114016595.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114032072.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114110501.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114128774.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114144873.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114230903.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114242437.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114300534.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615133925140.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615134024394.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105720048.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105810777.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105825048.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105833095.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223052134.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223039812.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223125233.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223228604.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223300214.png">
<meta property="og:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223322694.png">
<meta property="article:published_time" content="2022-04-16T04:22:57.000Z">
<meta property="article:modified_time" content="2022-04-16T04:42:14.830Z">
<meta property="article:author" content="supeBam">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://supebam.github.io/assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607161920925-1623205282384.png"><title>初识数据结构与算法 | supeBam`Blog</title><link ref="canonical" href="https://supebam.github.io/2022/04/16/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/life/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">生活</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">supeBam`Blog</div><div class="header-banner-info__subtitle">当你犹豫要不要去做一件事的时候，其实你内心已经有了选择，只是你还没有充足的理由去说服自己</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">初识数据结构与算法</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-04-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">14.7k</span></span></div></header><div class="post-body"><span id="more"></span>


        <h2 id="数据结构与算法"   >
          <a href="#数据结构与算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2>
      
        <h2 id="算法分析"   >
          <a href="#算法分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2>
      
        <h3 id="时间复杂度分析"   >
          <a href="#时间复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3>
      <p><strong>测试</strong></p>
<blockquote>
<p>随着输入规模的增大，算法的常数操作可以忽略不计</p>
<p>随着输入规模的增大，与最高次项相乘的常数可以忽略不计</p>
<p>最高次项的指数大的，随着n的增长，结果也会变得增长特别快</p>
<p>算法函数中n最高次幂越小，算法效率越高</p>
</blockquote>
<p><strong>结论</strong></p>
<blockquote>
<ol>
<li>算法函数中的常数可以忽略</li>
<li>算法函数中最高次幂的常数因子可以忽略</li>
<li>算法函数中最高次幂越小，算法效率越高</li>
</ol>
</blockquote>

        <h4 id="大O记法"   >
          <a href="#大O记法" class="heading-link"><i class="fas fa-link"></i></a><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h4>
      <p>记作：<strong>T(n) &#x3D; O(f(n))</strong></p>
<p>明确事情：<strong>执行次数&#x3D;执行时间</strong></p>
<p>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法</p>
<p>推导大O阶的表示法有以下几个规则可以使用:</p>
<ol>
<li><strong>用常数1取代运行时间中的所有加法常数；</strong></li>
<li><strong>在修改后的运行次数中，只保留高阶项；</strong></li>
<li><strong>如果高阶项存在，且常数因子不为1，则去除与这个项相乘的常数;</strong></li>
</ol>

        <h5 id="常见的大O阶"   >
          <a href="#常见的大O阶" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见的大O阶" class="headerlink" title="常见的大O阶"></a>常见的大O阶</h5>
      <ol>
<li><p><strong>线性阶</strong></p>
<p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长</p>
</li>
<li><p><strong>平方阶</strong></p>
<p>一般嵌套循环属于这种时间复杂度</p>
</li>
<li><p><strong>立方阶</strong></p>
<p>一般三层嵌套循环属于这种时间复杂度</p>
</li>
<li><p><strong>对数阶</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x&#x3D;n，得到x&#x3D;log(2)n，所以这个循环的时间复杂度为O(logn);</p>
</li>
<li><p><strong>常数阶</strong><br>一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607161920925-1623205282384.png" alt="image-20210607161920925"></p>
<p>复杂成都从低到高依次为：</p>
<p> O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3)</p>

        <h3 id="空间复杂度分析"   >
          <a href="#空间复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3>
      
        <h4 id="java中常见内存占用"   >
          <a href="#java中常见内存占用" class="heading-link"><i class="fas fa-link"></i></a><a href="#java中常见内存占用" class="headerlink" title="java中常见内存占用"></a>java中常见内存占用</h4>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607164814276.png" alt="image-20210607164814276"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210607164943394.png" alt="image-20210607164943394"></p>
<br>


        <h2 id="算法"   >
          <a href="#算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法" class="headerlink" title="算法"></a>算法</h2>
      
        <h3 id="排序算法"   >
          <a href="#排序算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3>
      
        <h4 id="简单排序"   >
          <a href="#简单排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4>
      <ol>
<li><p>冒泡排序(稳定)</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133342135.png" alt="image-20210608133342135"></p>
</li>
<li><p>选择排序(不稳定)</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133328051.png" alt="image-20210608133328051"></p>
</li>
<li><p>插入排序(稳定)</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608133302789.png" alt="image-20210608133302789"></p>
</li>
</ol>

        <h4 id="高级排序"   >
          <a href="#高级排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h4>
      <ol>
<li><p>希尔排序(不稳定)</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608135000407-1623205214916.png" alt="image-20210608135000407"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增长量h的确定： 增长量h的值固定的规则:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(h &lt; 数组的长度/<span class="number">2</span>)&#123;</span><br><span class="line">	h = 2h + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后确定h的最大值;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//h的减小规则:</span></span><br><span class="line">	h = h/<span class="number">2</span></span><br></pre></td></tr></table></div></figure>


</li>
<li><p>归并排序(递归)(稳定)</p>
<p>​    <img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608150304875.png" alt="image-20210608150304875"></p>
</li>
<li><p>快速排序(不稳定)</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608161637374-1623205238081.png" alt="image-20210608161637374"></p>
</li>
</ol>

        <h3 id="排序的稳定性"   >
          <a href="#排序的稳定性" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608170310300.png" alt="image-20210608170310300"></p>
<br>


        <h2 id="数据结构"   >
          <a href="#数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2>
      
        <h3 id="一、线性表"   >
          <a href="#一、线性表" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h3>
      <ul>
<li><p>前驱元素</p>
</li>
<li><p>后驱元素</p>
</li>
<li><p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210608171407017-1623205254540.png" alt="image-20210608171407017"></p>
<p><strong>线性表的分类</strong></p>
<p>存储方式:</p>
</li>
<li><p>​    顺序存储</p>
</li>
<li><p>​    链式存储</p>
</li>
</ul>

        <h4 id="1-1-顺序表"   >
          <a href="#1-1-顺序表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-顺序表" class="headerlink" title="1.1 顺序表"></a>1.1 顺序表</h4>
      <p>​        顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
<br>


        <h4 id="1-2-链表"   >
          <a href="#1-2-链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h4>
      <p>​        链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。</p>
<ol>
<li>单向链表</li>
<li>双向链表</li>
</ol>

        <h5 id="链表反转"   >
          <a href="#链表反转" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转整个链表</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//判断当前链表是否为空链表，是则返回，不是则调用reverse重载完成反转</span></span><br><span class="line">       <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(head.next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//反转指定的结点curr，并把反转后的结点返回</span></span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">reverse</span><span class="params">(Node curr)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (curr.next == <span class="literal">null</span>)&#123;</span><br><span class="line">           head.next = curr;</span><br><span class="line">           <span class="keyword">return</span> curr;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//递归的反转当前结点curr的下一个结点；返回值就是链表</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> reverse(curr.next);</span><br><span class="line">       <span class="comment">//让返回的结点的下一个结点变为当前结点</span></span><br><span class="line">       pre.next = curr;</span><br><span class="line">       <span class="comment">//把当前结点的下一个结点变为null</span></span><br><span class="line">       curr.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> curr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="快慢指针"   >
          <a href="#快慢指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5>
      <p><strong>快慢指针指的是定义两个指针，这两个指针的移动速度一快一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</strong></p>

        <h6 id="1-2-1中间值问题"   >
          <a href="#1-2-1中间值问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-1中间值问题" class="headerlink" title="1.2.1中间值问题"></a>1.2.1中间值问题</h6>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610102616158.png" alt="image-20210610102616158"></p>

        <h6 id="1-2-2-单向链表是否有环问题"   >
          <a href="#1-2-2-单向链表是否有环问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-2-单向链表是否有环问题" class="headerlink" title="1.2.2 单向链表是否有环问题"></a>1.2.2 单向链表是否有环问题</h6>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610104253725.png" alt="image-20210610104253725"></p>

        <h6 id="1-2-3-寻找单向链表环入口"   >
          <a href="#1-2-3-寻找单向链表环入口" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-3-寻找单向链表环入口" class="headerlink" title="1.2.3 寻找单向链表环入口"></a>1.2.3 寻找单向链表环入口</h6>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610110245937.png" alt="image-20210610110245937"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610110258691.png" alt="image-20210610110258691"></p>

        <h6 id="1-2-4-约瑟夫问题"   >
          <a href="#1-2-4-约瑟夫问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-4-约瑟夫问题" class="headerlink" title="1.2.4 约瑟夫问题"></a>1.2.4 约瑟夫问题</h6>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610122212921.png" alt="image-20210610122212921"></p>
<p>解决方法:</p>
<ol>
<li>数组</li>
<li>环形链表</li>
<li>递归</li>
</ol>
<br>


        <h4 id="1-3-栈"   >
          <a href="#1-3-栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h4>
      <p>​    <strong>栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一个数据被第一个读出来</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610133228809.png" alt="image-20210610133228809"></p>

        <h6 id="括号匹配问题"   >
          <a href="#括号匹配问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h6>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610154053255.png" alt="image-20210610154053255"></p>

        <h6 id="逆波兰表达式求值问题"   >
          <a href="#逆波兰表达式求值问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#逆波兰表达式求值问题" class="headerlink" title="逆波兰表达式求值问题"></a>逆波兰表达式求值问题</h6>
      <pre><code>**中缀表达式:**中缀表达式就是我们平常生活中使用的表达式，例如∶1+3*2,2-(1+3)等等，中缀表达式的特点是∶二元运算符总是置于两个操作数中间。
</code></pre>
<p><strong>中缀表达式：</strong></p>
<p>​        中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。</p>
<p><strong>逆波兰表达式(后缀表达式)：</strong></p>
<p>​        逆波兰表达式是波兰逻辑学家J·卢卡西维兹(J·Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点︰运算符总是放在跟它相关的操作数之后。</p>
<p>​    <img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610154740683.png" alt="image-20210610154740683"></p>
<br>


        <h4 id="1-4-队列"   >
          <a href="#1-4-队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h4>
      <p><strong>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210610175504457.png" alt="image-20210610175504457"></p>
<br>


        <h3 id="二、符号表"   >
          <a href="#二、符号表" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、符号表" class="headerlink" title="二、符号表"></a>二、符号表</h3>
      <p>**符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。 **</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611092534329.png" alt="image-20210611092534329"></p>

        <h6 id="有序符号表"   >
          <a href="#有序符号表" class="heading-link"><i class="fas fa-link"></i></a><a href="#有序符号表" class="headerlink" title="有序符号表"></a>有序符号表</h6>
      <br>


        <h3 id="树"   >
          <a href="#树" class="heading-link"><i class="fas fa-link"></i></a><a href="#树" class="headerlink" title="树"></a>树</h3>
      <p><strong>树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。 树是由n（n&gt;&#x3D;1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611095913141.png" alt="image-20210611095913141"></p>
<p><strong>树具有以下特点：</strong></p>
<p>​    1.每个结点有零个或多个子结点；</p>
<p>​    2.没有父结点的结点为根结点；</p>
<p>​    3.每一个非根结点只有一个父结点；</p>
<pre><code> 4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树
</code></pre>

        <h4 id="树的相关术语"   >
          <a href="#树的相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h4>
      <ul>
<li><p><strong>结点的度：</strong><br>一个结点含有的子树的个数称为该结点的度；</p>
</li>
<li><p><strong>叶结点：</strong><br>度为0的结点称为叶结点，也可以叫做终端结点</p>
</li>
<li><p><strong>分支结点：</strong><br>度不为0的结点称为分支结点，也可以叫做非终端结点</p>
</li>
<li><p><strong>结点的层次：</strong><br>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推结点的层序编号：<br>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p>
</li>
<li><p><strong>树的度：</strong><br>树中所有结点的度的最大值<br>树的高度(深度)：<br>树中结点的最大层次</p>
</li>
<li><p><strong>森林：</strong><br>m（m&gt;&#x3D;0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根<br>结点，森林就变成一棵树</p>
</li>
<li><p><strong>孩子结点：</strong> </p>
<p>一个结点的直接后继结点称为该结点的孩子结点 </p>
</li>
<li><p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点 兄弟结点： 同一双亲结点的孩子结点间互称兄弟结点</p>
</li>
</ul>

        <h4 id="二叉树"   >
          <a href="#二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4>
      <p><strong>二叉树就是度不超过2的树(每个结点最多有两个子结点)</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104159340.png" alt="image-20210611104159340"></p>
<p><strong>满二叉树：</strong></p>
<p>​     一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104246540.png" alt="image-20210611104246540"></p>
<p><strong>完全二叉树：</strong> </p>
<p>​    叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611104314776.png" alt="image-20210611104314776"></p>

        <h4 id="二叉查找树"   >
          <a href="#二叉查找树" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4>
      <pre><code>插入方法put实现思想：
</code></pre>
<ol>
<li><p>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p>
</li>
<li><p>如果当前树不为空，则从根结点开始：<br>2.1    如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；<br>   2.2    如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；<br>   2.3    如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</p>
</li>
</ol>
<p>查询方法get实现思想：<br>从根节点开始：</p>
<ol>
<li><p>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</p>
</li>
<li><p>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p>
</li>
<li><p>如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p>
</li>
</ol>
<p>删除方法delete实现思想：</p>
<ol>
<li><p>找到被删除结点；</p>
</li>
<li><p>找到被删除结点右子树中的最小结点minNode</p>
</li>
<li><p>删除右子树中的最小结点</p>
</li>
<li><p>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子<br>树</p>
</li>
<li><p>让被删除结点的父节点指向最小结点minNode</p>
</li>
</ol>

        <h4 id="二叉树的基础遍历"   >
          <a href="#二叉树的基础遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的基础遍历" class="headerlink" title="二叉树的基础遍历"></a>二叉树的基础遍历</h4>
      <ol>
<li><p><strong>前序遍历</strong></p>
<p>先访问根结点，然后再访问左子树，最后访问右子树</p>
</li>
<li><p><strong>中序遍历</strong></p>
<p>先访问左子树，中间访问根节点，最后访问右子树</p>
</li>
<li><p><strong>后序遍历</strong></p>
<p>先访问左子树，再访问右子树，最后访问根节点</p>
</li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611142912885.png" alt="image-20210611142912885"></p>

        <h4 id="二叉树的层序遍历"   >
          <a href="#二叉树的层序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611145246660.png" alt="image-20210611145246660"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611155437540.png" alt="image-20210611155437540"></p>

        <h4 id="二叉树的最大深度问题"   >
          <a href="#二叉树的最大深度问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a>二叉树的最大深度问题</h4>
      <p><strong>给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）;</strong></p>
<p>实现步骤：</p>
<p>​     1.如果根结点为空，则最大深度为0；</p>
<pre><code> 2.计算左子树的最大深度；
</code></pre>
<p>​     3.计算右子树的最大深度；</p>
<pre><code> 4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1
</code></pre>

        <h4 id="折纸问题"   >
          <a href="#折纸问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h4>
      <p>​    <strong>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折</strong><br><strong>痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上</strong><br><strong>到下依次是下折痕、下折痕和上折痕。</strong><br><strong>给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N&#x3D;1时，打</strong><br><strong>印： down；N&#x3D;2时，打印： down down up</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611172719602.png" alt="image-20210611172719602"></p>
<p>​        我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折<br>痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构<br>来描述对折后产生的折痕。</p>
<p>这棵树有这样的特点：<br>    1. 根结点为下折痕；<br>    2. 每一个结点的左子结点为下折痕；<br>    3. 每一个结点的右子结点为上折痕；</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210611172817988.png" alt="image-20210611172817988"></p>
<br>


        <h3 id="堆"   >
          <a href="#堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆" class="headerlink" title="堆"></a>堆</h3>
      <p><strong>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</strong></p>
<p>堆的特性： </p>
<p>​    1.它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210612165830727.png" alt="image-20210612165830727"></p>
<p>2.它通常用数组来实现。 具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210612165847273.png" alt="image-20210612165847273"></p>
<p>如果一个结点的位置为k，则它的父结点的位置为[k&#x2F;2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不<br>使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k&#x2F;2,向下一层就<br>令k等于2k或2k+1。<br>    3.每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个<br>子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</p>
<br>


        <h3 id="优先队列"   >
          <a href="#优先队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3>
      <p><strong>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出<br>队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我<br>们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的<br>队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613093509772.png" alt="image-20210613093509772"></p>
<p>**优先队列按照其作用不同，可以分为以下两种： **</p>
<p>​    **最大优先队列： 可以获取并删除队列中最大的值 **</p>
<p>​    <strong>最小优先队列： 可以获取并删除队列中最小的值</strong></p>
<br>


        <h3 id="索引优先队列"   >
          <a href="#索引优先队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h3>
      <p><strong>在之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一<br>个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的<br>基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。</strong></p>
<p><strong>索引优先队列实现思想</strong></p>
<p><strong>步骤一：</strong></p>
<p>​        存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实<br>现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。<br>​        最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是<br>items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到<br>items[k]即可。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105501688.png" alt="image-20210613105501688"></p>
<p><strong>步骤二：</strong><br>        步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是，items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq</p>
<p>​    <img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105552102.png" alt="image-20210613105552102"></p>
<p><strong>步骤三：</strong><br>        通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要<br>对items中的元素进行修改，比如让items[0]&#x3D;“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pq[9]中元素的位置呢？<br>最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可，但是效率很低。<br>我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如：<br>在pq数组中：pq[1]&#x3D;6;那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]&#x3D;1;</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613105630696.png" alt="image-20210613105630696"></p>
<p>​        当有了pq数组后，如果我们修改items[0]&#x3D;”H”，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]&#x3D;9, 那么直接调整pq[9]即可。</p>
<br>


        <h3 id="平衡树"   >
          <a href="#平衡树" class="heading-link"><i class="fas fa-link"></i></a><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3>
      
        <h4 id="引入"   >
          <a href="#引入" class="heading-link"><i class="fas fa-link"></i></a><a href="#引入" class="headerlink" title="引入"></a>引入</h4>
      <p>​        之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，大部分情况下，确实是这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。 例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据，那么最终构造出来的树是长得下面这个样子：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112410494.png" alt="image-20210613112410494"></p>
<p>​        我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向 左边分支，如果我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情 况下，查找的效率依旧会很好。</p>

        <h4 id="2-3查找树"   >
          <a href="#2-3查找树" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h4>
      <p>​        为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p>

        <h5 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5>
      <p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p>
<p>​    <strong>2-结点：</strong>含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大<br>于该结点。<br>​    <strong>3-结点：</strong>含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112615828.png" alt="image-20210613112615828"></p>

        <h5 id="2-3树的性质"   >
          <a href="#2-3树的性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3树的性质" class="headerlink" title="2-3树的性质"></a>2-3树的性质</h5>
      <p>通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。<br>一棵完全平衡的2-3树具有以下性质：</p>
<ol>
<li><p><strong>任意空链接到根结点的路径长度都是相等的。</strong></p>
</li>
<li><p><strong>4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。</strong></p>
</li>
<li><p><strong>2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。</strong></p>
</li>
</ol>

        <h5 id="2-3树的实现"   >
          <a href="#2-3树的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3树的实现" class="headerlink" title="2-3树的实现"></a>2-3树的实现</h5>
      <p>​    直接实现2-3树比较复杂，因为：<br>​    需要处理不同的结点类型，非常繁琐；<br>​    需要多次比较操作来将结点下移；<br>     需要上移来拆分4-结点；<br>     拆分4-结点的情况有很多种；<br>2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重<br>要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要.</p>

        <h5 id="查找"   >
          <a href="#查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找" class="headerlink" title="查找"></a>查找</h5>
      <p>​    将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112721103.png" alt="image-20210613112721103"></p>

        <h5 id="插入"   >
          <a href="#插入" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入" class="headerlink" title="插入"></a>插入</h5>
      
        <h6 id="向2-结点中插入新键"   >
          <a href="#向2-结点中插入新键" class="heading-link"><i class="fas fa-link"></i></a><a href="#向2-结点中插入新键" class="headerlink" title="向2-结点中插入新键"></a>向2-结点中插入新键</h6>
      <p>​        往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节点结束于一个3-结点，那么可能有点麻烦。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112813302.png" alt="image-20210613112813302"></p>

        <h6 id="向一棵只含有一个3-结点的树中插入新键"   >
          <a href="#向一棵只含有一个3-结点的树中插入新键" class="heading-link"><i class="fas fa-link"></i></a><a href="#向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="向一棵只含有一个3-结点的树中插入新键"></a>向一棵只含有一个3-结点的树中插入新键</h6>
      <p>​        假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112858049.png" alt="image-20210613112858049"></p>

        <h6 id="向一个父结点为2-结点的3-结点中插入新键"   >
          <a href="#向一个父结点为2-结点的3-结点中插入新键" class="heading-link"><i class="fas fa-link"></i></a><a href="#向一个父结点为2-结点的3-结点中插入新键" class="headerlink" title="向一个父结点为2-结点的3-结点中插入新键"></a>向一个父结点为2-结点的3-结点中插入新键</h6>
      <p>​        和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中 的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613112930532.png" alt="image-20210613112930532"></p>

        <h6 id="向一个父结点为3-结点的3-结点中插入新键"   >
          <a href="#向一个父结点为3-结点的3-结点中插入新键" class="heading-link"><i class="fas fa-link"></i></a><a href="#向一个父结点为3-结点的3-结点中插入新键" class="headerlink" title="向一个父结点为3-结点的3-结点中插入新键"></a>向一个父结点为3-结点的3-结点中插入新键</h6>
      <p>​        当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点， 插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其 变为3-结点，不需要继续进行拆分。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113038613.png" alt="image-20210613113038613"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113118592.png" alt="image-20210613113118592"></p>

        <h6 id="分解根结点"   >
          <a href="#分解根结点" class="heading-link"><i class="fas fa-link"></i></a><a href="#分解根结点" class="headerlink" title="分解根结点"></a>分解根结点</h6>
      <p>​        当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将 根结点拆分为两个2-结点，树的高度加1。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613113213757.png" alt="image-20210613113213757"></p>

        <h4 id="红黑树"   >
          <a href="#红黑树" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4>
      <p>​        我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点<br>都是2-结点，树的高度为lgN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。</p>
<p>​        红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。</p>
<p>​        我们将树中的链接分为两种类型：<br><strong>红链接：将两个2-结点连接起来构成一个3-结点；</strong></p>
<p><strong>黑链接：则是2-3树中的普通链接。</strong><br>        确切的说，我们将3-结点表示为由由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145651921.png" alt="image-20210613145651921"></p>

        <h5 id="红黑树定义"   >
          <a href="#红黑树定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h5>
      <p>红黑树是含有红黑链接并满足下列条件的二叉查找树： </p>
<ol>
<li><p>红链接均为左链接；</p>
</li>
<li><p>没有任何一个结点同时和两条红链接相连；</p>
</li>
<li><p>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同； </p>
<p>下面是红黑树与2-3树的对应关系：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145757679.png" alt="image-20210613145757679"></p>
</li>
</ol>

        <h5 id="平衡化"   >
          <a href="#平衡化" class="heading-link"><i class="fas fa-link"></i></a><a href="#平衡化" class="headerlink" title="平衡化"></a>平衡化</h5>
      <p>​        在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。</p>

        <h6 id="左旋"   >
          <a href="#左旋" class="heading-link"><i class="fas fa-link"></i></a><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h6>
      <p>​    当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。<br>​    前提：当前结点为h，它的右子结点为x；</p>
<p>​    <strong>左旋过程：</strong></p>
<p>​     <strong>1.让x的左子结点变为h的右子结点：h.right&#x3D;x.left;</strong><br>     <strong>2.让h成为x的左子结点：x.left&#x3D;h;</strong><br>     <strong>3.让h的color属性变为x的color属性值：x.color&#x3D;h.color;</strong><br>     <strong>4.让h的color属性变为RED：h.color&#x3D;true;</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613145950939.png" alt="image-20210613145950939"></p>
<p>​    </p>

        <h6 id="右旋"   >
          <a href="#右旋" class="heading-link"><i class="fas fa-link"></i></a><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h6>
      <p>​        当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋</p>
<p>前提：当前结点为h，它的左子结点为x；</p>
<p><strong>右旋过程：</strong></p>
<ol>
<li><strong>让x的右子结点成为h的左子结点：h.left &#x3D; x.right;</strong></li>
<li><strong>让h成为x的右子结点：x.right&#x3D;h;</strong></li>
<li><strong>让x的color变为h的color属性值：x.color &#x3D; h.color;</strong></li>
<li><strong>让h的color为RED；</strong></li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613150028180.png" alt="image-20210613150028180"></p>

        <h6 id="颜色反转"   >
          <a href="#颜色反转" class="heading-link"><i class="fas fa-link"></i></a><a href="#颜色反转" class="headerlink" title="颜色反转"></a>颜色反转</h6>
      <p>​        当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子 结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613161810368.png" alt="image-20210613161810368"></p>

        <h4 id="B-树"   >
          <a href="#B-树" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4>
      <p>B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。</p>
<p>现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p>
<ol>
<li><strong>每个结点最多有M-1个key，并且以升序排列；</strong></li>
<li><strong>每个结点最多能有M个子结点；</strong></li>
<li><strong>根结点至少有两个子结点；</strong></li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613164915974.png" alt="image-20210613164915974"></p>
<p>​        在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这 样在某些应用场景下，就可以体现出它的优势。</p>

        <h6 id="B树存储数据"   >
          <a href="#B树存储数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#B树存储数据" class="headerlink" title="B树存储数据"></a>B树存储数据</h6>
      <p><strong>若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165133876.png" alt="image-20210613165133876"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165144822.png" alt="image-20210613165144822"></p>

        <h6 id="B树在磁盘文件中的应用"   >
          <a href="#B树在磁盘文件中的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#B树在磁盘文件中的应用" class="headerlink" title="B树在磁盘文件中的应用"></a>B树在磁盘文件中的应用</h6>
      <p>​        在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是 通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165214463.png" alt="image-20210613165214463"></p>
<p>​        磁盘由盘片构成,每个盘片有两面，又称为盘面 。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内 。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165247569.png" alt="image-20210613165247569"></p>
<p>​        磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 寻道时间，旋转时间，以及传送时间。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I&#x2F;O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放内存。这样做的理论依据是计算机科学中著名的</p>
<p>​        局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此预读可以提高I&#x2F;O效率。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。<br>​        文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I&#x2F;O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。</p>

        <h4 id="B-树-1"   >
          <a href="#B-树-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4>
      <p>B+树是对B树的一种变形树，它与B树的差异在于： </p>
<ol>
<li><strong>非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；</strong> </li>
<li><strong>树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</strong></li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210613165434398.png" alt="image-20210613165434398"></p>
<p><strong>B+ 树的优点在于：</strong><br>    1.由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的<br>key。 </p>
<p>​    2.B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序<br>排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</p>
<p><strong>B树的优点在于：</strong><br>        由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，</p>
<p>​        但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。</p>

        <h3 id="并查集"   >
          <a href="#并查集" class="heading-link"><i class="fas fa-link"></i></a><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>
      <p>并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作： </p>
<p>​    **查询元素p和元素q是否属于同一组 **</p>
<p>​    <strong>合并元素p和元素q所在的组</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084304098.png" alt="image-20210614084304098"></p>
<p>并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：</p>
<ol>
<li>每个元素都唯一的对应一个结点；</li>
<li>每一组数据中的多个元素都在同一颗树中；</li>
<li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；</li>
<li>元素在树中并没有子父级关系的硬性要求；</li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084324958.png" alt="image-20210614084324958"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084536493.png" alt="image-20210614084536493"></p>

        <h5 id="UF-Tree算法优化"   >
          <a href="#UF-Tree算法优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#UF-Tree算法优化" class="headerlink" title="UF_Tree算法优化"></a>UF_Tree算法优化</h5>
      <p>为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结构中的eleAndGourp数组的含义进行重新设定：</p>
<p>​    1.我们仍然让eleAndGroup数组的索引作为某个结点的元素；</p>
<p>​    2.eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084458710.png" alt="image-20210614084458710"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614094622616.png" alt="image-20210614094622616"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084615401.png" alt="image-20210614084615401"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614084624978.png" alt="image-20210614084624978"></p>

        <h5 id="UF-Tree-Weighted"   >
          <a href="#UF-Tree-Weighted" class="heading-link"><i class="fas fa-link"></i></a><a href="#UF-Tree-Weighted" class="headerlink" title="UF_Tree_Weighted"></a>UF_Tree_Weighted</h5>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614094541050.png" alt="image-20210614094541050"></p>

        <h6 id="路径压缩"   >
          <a href="#路径压缩" class="heading-link"><i class="fas fa-link"></i></a><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h6>
      <p>​        UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小<br>树的深度。</p>

        <h4 id="畅通工程"   >
          <a href="#畅通工程" class="heading-link"><i class="fas fa-link"></i></a><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h4>
      <p>​        某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。</p>
<p>问最少还需要建设多少条道路？</p>
<p>在我们的测试数据文件夹中有一个trffic_project.txt文件，它就是诚征道路统计表，下面是对数据的解释：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614095244785.png" alt="image-20210614095244785"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	总共有<span class="number">20</span>个城市，目前已经修改好了<span class="number">7</span>条道路，问还需要修建多少条道路，才能让这<span class="number">20</span>个城市之间全部相通？</span><br><span class="line">	解题思路：</span><br><span class="line"><span class="number">1.</span>创建一个并查集UF_Tree_Weighted(<span class="number">20</span>);</span><br><span class="line"><span class="number">2.</span>分别调用union(<span class="number">0</span>,<span class="number">1</span>),union(<span class="number">6</span>,<span class="number">9</span>),union(<span class="number">3</span>,<span class="number">8</span>),union(<span class="number">5</span>,<span class="number">11</span>),union(<span class="number">2</span>,<span class="number">12</span>),union(<span class="number">6</span>,<span class="number">10</span>),union(<span class="number">4</span>,<span class="number">8</span>)，表示已经修建好的</span><br><span class="line">道路把对应的城市连接起来；</span><br><span class="line"><span class="number">3.</span>如果城市全部连接起来，那么并查集中剩余的分组数目为<span class="number">1</span>，所有的城市都在一个树中，所以，只需要获取当前</span><br><span class="line">并查集中剩余的数目，减去<span class="number">1</span>，就是还需要修建的道路数目；</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="图"   >
          <a href="#图" class="heading-link"><i class="fas fa-link"></i></a><a href="#图" class="headerlink" title="图"></a>图</h3>
      <p>​    <strong>定义：图是由一组顶点和一组能够将两个顶点相连的边组成的</strong></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100701610.png" alt="image-20210614100701610"></p>
<p>特殊的图： </p>
<ol>
<li><p>自环：即一条连接一个顶点和其自身的边； </p>
</li>
<li><p>平行边：连接同一对顶点的两条边；</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100730351.png" alt="image-20210614100730351"></p>
</li>
</ol>
<p>图的分类： 按照连接两个顶点的边的不同，可以把图分为以下两种：</p>
<ul>
<li><p>​    无向图：边仅仅连接两个顶点，没有其他含义； </p>
</li>
<li><p>​    有向图：边不仅连接两个顶点，并且具有方向；</p>
</li>
</ul>

        <h4 id="无向图的相关术语"   >
          <a href="#无向图的相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#无向图的相关术语" class="headerlink" title="无向图的相关术语"></a>无向图的相关术语</h4>
      <p>相邻顶点：<br>当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。<br><strong>度：</strong><br>    某个顶点的度就是依附于该顶点的边的个数<br><strong>子图：</strong><br>    是一幅图的所有边的子集(包含这些边依附的顶点)组成的图；<br><strong>路径：</strong><br>    是由边顺序连接的一系列的顶点组成<br><strong>环：</strong><br>    是一条至少含有一条边且终点和起点相同的路径</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100858414.png" alt="image-20210614100858414"></p>
<p>​    <strong>连通图</strong>： 如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图 </p>
<p>​    <strong>连通子图</strong>： 一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614100930467.png" alt="image-20210614100930467"></p>

        <h4 id="图的存储结构"   >
          <a href="#图的存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4>
      <p>要表示一幅图，只需要表示清楚以下两部分内容即可： </p>
<ol>
<li><p>图中所有的顶点； </p>
</li>
<li><p>所有连接顶点的边；</p>
<p><strong>常见的图的存储结构有两种：邻接矩阵和邻接表</strong></p>
</li>
</ol>

        <h5 id="邻接矩阵"   >
          <a href="#邻接矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5>
      <ol>
<li>使用一个V*V的二维数组int[V][V] adj,把索引的值看做是顶点； </li>
<li>如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可。</li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614101930119.png" alt="image-20210614101930119"></p>
<p>很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能 不够用。</p>

        <h5 id="邻接表"   >
          <a href="#邻接表" class="heading-link"><i class="fas fa-link"></i></a><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5>
      <p>1.使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点； </p>
<p>2.每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614102001236.png" alt="image-20210614102001236"></p>

        <h4 id="图的搜索"   >
          <a href="#图的搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h4>
      <p>​        在很多情况下，我们需要遍历图，得到图的一些性质，例如，找出图中与指定的顶点相连的所有顶点，或者判定某 个顶点与指定顶点是否相通，是非常常见的需求。 有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，接下来我们分别讲解这两种搜索算法。</p>

        <h5 id="深度优先搜索"   >
          <a href="#深度优先搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5>
      <p>​        所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找 兄弟结点。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614151349050.png" alt="image-20210614151349050"></p>
<p>​        很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，如果没有搜索，标记为false；</p>

        <h5 id="广度优先搜索"   >
          <a href="#广度优先搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5>
      <p>​        所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后 找子结点。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614151429465.png" alt="image-20210614151429465"></p>

        <h4 id="畅通工程续1"   >
          <a href="#畅通工程续1" class="heading-link"><i class="fas fa-link"></i></a><a href="#畅通工程续1" class="headerlink" title="畅通工程续1"></a>畅通工程续1</h4>
      <p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192345755.png" alt="image-20210614192345755"></p>
<p>总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？<br>解题思路：<br>1.创建一个图Graph对象，表示城市；<br>2.分别调用 addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已经修建好的道路把对应的城市连接起来；<br>3.通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象；<br>4.调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相<br>通。</p>

        <h4 id="路径查找"   >
          <a href="#路径查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#路径查找" class="headerlink" title="路径查找"></a>路径查找</h4>
      <p>​        在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地 城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是： 从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192515122.png" alt="image-20210614192515122"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210614192549752.png" alt="image-20210614192549752"></p>

        <h4 id="有向图的相关术语"   >
          <a href="#有向图的相关术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#有向图的相关术语" class="headerlink" title="有向图的相关术语"></a>有向图的相关术语</h4>
      <p><strong>定义：</strong><br>    有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。<br><strong>出度：</strong><br>    由某个顶点指出的边的个数称为该顶点的出度。<br><strong>入度：</strong><br>    指向某个顶点的边的个数称为该顶点的入度。<br>有向路径：<br>    由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。<br><strong>有向环：</strong><br>    一条至少含有一条边，且起点和终点相同的有向路径。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615093211138.png" alt="image-20210615093211138"></p>
<p>一副有向图中两个顶点v和w可能存在以下四种关系：</p>
<ol>
<li>没有边相连； </li>
<li>存在从v到w的边v—&gt;w; </li>
<li>存在从w到v的边w—&gt;v; </li>
<li>既存在w到v的边，也存在v到w的边，即双向连接；</li>
</ol>

        <h4 id="拓扑排序"   >
          <a href="#拓扑排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4>
      <p>​        在现实生活中，我们经常会同一时间接到很多任务去完成，但是这些任务的完成是有先后次序的。以我们学习java学科为例，我们需要学习很多知识，但是这些知识在学习的过程中是需要按照先后次序来完成的。从java基础，到jsp&#x2F;servlet，到ssm，到springboot等是个循序渐进且有依赖的过程。在学习jsp前要首先掌握java基础和html基础，学习ssm框架前要掌握jsp&#x2F;servlet之类才行。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100708182.png" alt="image-20210615100708182"></p>
<p>为了简化问题，我们使用整数为顶点编号的标准模型来表示这个案例：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100722311.png" alt="image-20210615100722311"></p>
<p>​        此时如果某个同学要学习这些课程，就需要指定出一个学习的方案，我们只需要对图中的顶点进行排序，让它转换 为一个线性序列，就可以解决问题，这时就需要用到一种叫拓扑排序的算法。</p>
<p>​        拓扑排序： 给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明 确的表示出每个顶点的优先级。</p>
<p>下列是一副拓扑排序后的示意图：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100757487.png" alt="image-20210615100757487"></p>

        <h5 id="检测有向图的环"   >
          <a href="#检测有向图的环" class="heading-link"><i class="fas fa-link"></i></a><a href="#检测有向图的环" class="headerlink" title="检测有向图的环"></a>检测有向图的环</h5>
      <p>​        如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有 问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个 环：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100841745.png" alt="image-20210615100841745"></p>
<p>因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。</p>
<p>在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：</p>
<ol>
<li>在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；</li>
<li>如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；</li>
<li>如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；<br><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100916768.png" alt="image-20210615100916768"></li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615100927136.png" alt="image-20210615100927136"></p>

        <h5 id="基于深度优先的顶点排序"   >
          <a href="#基于深度优先的顶点排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于深度优先的顶点排序" class="headerlink" title="基于深度优先的顶点排序"></a>基于深度优先的顶点排序</h5>
      <p>​        如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜索的基础上，添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。</p>

        <h6 id="顶点排序的实现"   >
          <a href="#顶点排序的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#顶点排序的实现" class="headerlink" title="顶点排序的实现"></a>顶点排序的实现</h6>
      <p>​        在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该 顶点放入到reversePost中，这样就可以实现顶点排序。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104208108.png" alt="image-20210615104208108"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104220502.png" alt="image-20210615104220502"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615104238387.png" alt="image-20210615104238387"></p>

        <h4 id="加权无向图"   >
          <a href="#加权无向图" class="heading-link"><i class="fas fa-link"></i></a><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h4>
      <p>​        加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞才能使时间成本最低或者是金钱成本最低？</p>
<p>在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过那条路径到达4顶点最好<br>呢？此时就要考虑，那条路径的成本最低。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615112619545.png" alt="image-20210615112619545"></p>

        <h4 id="最小生成树"   >
          <a href="#最小生成树" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4>
      <p>​        之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才 能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。</p>

        <h5 id="最小生成树定义及相关约定"   >
          <a href="#最小生成树定义及相关约定" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小生成树定义及相关约定" class="headerlink" title="最小生成树定义及相关约定"></a>最小生成树定义及相关约定</h5>
      <p>​        图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边 的权重之和)最小的生成树</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615113855769.png" alt="image-20210615113855769"></p>
<p><strong>约定:</strong></p>
<p>​        只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图 的最小生成树，合并到一起称为最小生成森林。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615113926655.png" alt="image-20210615113926655"></p>
<p>​        所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算 法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。</p>

        <h5 id="最小生成树原理"   >
          <a href="#最小生成树原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小生成树原理" class="headerlink" title="最小生成树原理"></a>最小生成树原理</h5>
      
        <h6 id="树的性质"   >
          <a href="#树的性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h6>
      <ol>
<li>用一条边接树中的任意两个顶点都会产生一个新的环；</li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114016595.png" alt="image-20210615114016595"></p>
<ol start="2">
<li>从树中删除任意一条边，将会得到两棵独立的树；</li>
</ol>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114032072.png" alt="image-20210615114032072"></p>

        <h5 id="切分定理"   >
          <a href="#切分定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h5>
      <p>要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。</p>
<p><strong>切分：</strong><br>    将图的所有顶点按照某些规则分为两个非空且没有交集的集合。</p>
<p><strong>横切边：</strong><br>    连接两个属于不同集合的顶点的边称之为横切边。</p>
<p>例如我们将图中的顶点切分为两个集合，灰色顶点属于一个集合，白色顶点属于另外一个集合，那么效果如下：</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114110501.png" alt="image-20210615114110501"></p>
<p>切分定理： 在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114128774.png" alt="image-20210615114128774"></p>
<p>注意:一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114144873.png" alt="image-20210615114144873"></p>

        <h5 id="贪心算法"   >
          <a href="#贪心算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5>
      <p>​        贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114230903.png" alt="image-20210615114230903"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114242437.png" alt="image-20210615114242437"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615114300534.png" alt="image-20210615114300534"></p>
<p>​        计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在于保存切分和判定权重最小的横切边的方式。</p>

        <h5 id="Prim算法"   >
          <a href="#Prim算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5>
      <p>我们学习第一种计算最小生成树的方法叫Prim算法，它的每一步都会为一棵生成中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入到树中。</p>
<p>Prim算法的切分规则：<br>把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。</p>

        <h6 id="Prim算法的实现原理"   >
          <a href="#Prim算法的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Prim算法的实现原理" class="headerlink" title="Prim算法的实现原理"></a>Prim算法的实现原理</h6>
      <p>Prim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作，可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。<br>我们在设计API的时候，使用最小索引优先队列存放树中顶点与非树中顶点的有效横切边，那么它是如何表示的<br>呢？我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615133925140.png" alt="image-20210615133925140"></p>
<p>​        初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表示了。<br>​        现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重<br>最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也成为了横切边，这时需要做两个操作：<br> 1、0-7这条边已经不是横切边了，需要让它失效：只需要调用最小索引优先队列的delMin()方法即可完成；<br> 2、2和4顶点各有两条连接指向最小生成树，需要只保留一条：4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210615134024394.png" alt="image-20210615134024394"></p>
<p>​    </p>
<p>我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中。</p>

        <h5 id="Kruskal算法"   >
          <a href="#Kruskal算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5>
      <p>kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。</p>
<p>​    <strong>kruskal算法和prim算法的区别：</strong></p>
<p>​        Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105720048.png" alt="image-20210616105720048"></p>

        <h6 id="Kruskal算法的实现原理"   >
          <a href="#Kruskal算法的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Kruskal算法的实现原理" class="headerlink" title="Kruskal算法的实现原理"></a>Kruskal算法的实现原理</h6>
      <p>​        在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105810777.png" alt="image-20210616105810777"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105825048.png" alt="image-20210616105825048"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616105833095.png" alt="image-20210616105833095"></p>

        <h4 id="加权有向图"   >
          <a href="#加权有向图" class="heading-link"><i class="fas fa-link"></i></a><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h4>
      <p>​        之前学习的加权无向图中，边是没有方向的，并且同一条边会同时出现在该边的两个顶点的邻接表中，为了能够处 理含有方向性的图的问题，我们需要实现以下加权有向图。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223052134.png" alt="image-20210616223052134"></p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223039812.png" alt="image-20210616223039812"></p>

        <h5 id="最短路径"   >
          <a href="#最短路径" class="heading-link"><i class="fas fa-link"></i></a><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h5>
      <p>定义：</p>
<p>​     在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223125233.png" alt="image-20210616223125233"></p>
<p>性质：<br>    1.路径具有方向性；<br>    2.权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低<br>    3.只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径，为了简化问题，这里只考虑连通图。<br>    4.最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一条即可。</p>
<p>最短路径树：<br>    给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。</p>

        <h5 id="松弛技术"   >
          <a href="#松弛技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#松弛技术" class="headerlink" title="松弛技术"></a>松弛技术</h5>
      <p>​        松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还 有存在更短的路径，那么把皮筋转移到更短的路径上，皮筋就可以放松了。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223228604.png" alt="image-20210616223228604"></p>
<p>松弛这种简单的原理刚好可以用来计算最短路径树。<br>        在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]&#x3D;0；顶点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条件更新edgeTo和distTo中的数据，最终就可以得到最短路劲树。</p>
<p><strong>边的松弛：</strong><br>    放松边v-&gt;w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？<br>如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]&#x3D;表示v-&gt;w这条边的<br>DirectedEdge对象，distTo[w]&#x3D;distTo[v]+v-&gt;w这条边的权重；如果不是，则忽略v-&gt;w这条边。</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223300214.png" alt="image-20210616223300214"></p>
<p>​    <strong>顶点的松弛：</strong></p>
<p>​     顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶 点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。 如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0-&gt;2-&gt;7&gt;3-&gt;6的过程如下:</p>
<p><img src="/../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20210616223322694.png" alt="image-20210616223322694"></p>

        <h5 id="Dijstra算法实现"   >
          <a href="#Dijstra算法实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dijstra算法实现" class="headerlink" title="Dijstra算法实现"></a>Dijstra算法实现</h5>
      <p>​        Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边 是有效横切边pq队列中的权重最小的边。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://supebam.github.io">supeBam</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://supebam.github.io/2022/04/16/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://supebam.github.io/2022/04/16/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://supebam.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2022/04/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><span class="paginator-prev__text">排序算法</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">
          数据结构与算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">
          算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">
          时间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7O%E8%AE%B0%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">
          大O记法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%A7O%E9%98%B6"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">
          常见的大O阶</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">
          空间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          java中常见内存占用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">
          算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">
          排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          简单排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          高级排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">
          排序的稳定性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">
          数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">
          一、线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          1.1 顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">
          1.2 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">
          链表反转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">
          快慢指针</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-1%E4%B8%AD%E9%97%B4%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">
          1.2.1中间值问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-2-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">
          1.2.2 单向链表是否有环问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-3-%E5%AF%BB%E6%89%BE%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%8E%AF%E5%85%A5%E5%8F%A3"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">
          1.2.3 寻找单向链表环入口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-4-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.2.2.4.</span> <span class="toc-text">
          1.2.4 约瑟夫问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%A0%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">
          1.3 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.0.1.</span> <span class="toc-text">
          括号匹配问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.0.2.</span> <span class="toc-text">
          逆波兰表达式求值问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E9%98%9F%E5%88%97"><span class="toc-number">4.1.4.</span> <span class="toc-text">
          1.4 队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">
          二、符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">4.2.0.0.1.</span> <span class="toc-text">
          有序符号表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">4.3.</span> <span class="toc-text">
          树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          树的相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.3.3.</span> <span class="toc-text">
          二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E9%81%8D%E5%8E%86"><span class="toc-number">4.3.4.</span> <span class="toc-text">
          二叉树的基础遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.3.5.</span> <span class="toc-text">
          二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.6.</span> <span class="toc-text">
          二叉树的最大深度问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.7.</span> <span class="toc-text">
          折纸问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">4.4.</span> <span class="toc-text">
          堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">4.5.</span> <span class="toc-text">
          优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">4.6.</span> <span class="toc-text">
          索引优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">4.7.</span> <span class="toc-text">
          平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">4.7.1.</span> <span class="toc-text">
          引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.7.2.</span> <span class="toc-text">
          2-3查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">
          定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">
          2-3树的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">
          2-3树的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">4.7.2.4.</span> <span class="toc-text">
          查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">4.7.2.5.</span> <span class="toc-text">
          插入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.7.2.5.1.</span> <span class="toc-text">
          向2-结点中插入新键</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.7.2.5.2.</span> <span class="toc-text">
          向一棵只含有一个3-结点的树中插入新键</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA2-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.7.2.5.3.</span> <span class="toc-text">
          向一个父结点为2-结点的3-结点中插入新键</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA3-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.7.2.5.4.</span> <span class="toc-text">
          向一个父结点为3-结点的3-结点中插入新键</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E6%A0%B9%E7%BB%93%E7%82%B9"><span class="toc-number">4.7.2.5.5.</span> <span class="toc-text">
          分解根结点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">4.7.3.</span> <span class="toc-text">
          红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">
          红黑树定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%8C%96"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">
          平衡化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B"><span class="toc-number">4.7.3.2.1.</span> <span class="toc-text">
          左旋</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B"><span class="toc-number">4.7.3.2.2.</span> <span class="toc-text">
          右旋</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">4.7.3.2.3.</span> <span class="toc-text">
          颜色反转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">4.7.4.</span> <span class="toc-text">
          B-树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#B%E6%A0%91%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">4.7.4.0.1.</span> <span class="toc-text">
          B树存储数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B%E6%A0%91%E5%9C%A8%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.7.4.0.2.</span> <span class="toc-text">
          B树在磁盘文件中的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">4.7.5.</span> <span class="toc-text">
          B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.8.</span> <span class="toc-text">
          并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UF-Tree%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">4.8.0.1.</span> <span class="toc-text">
          UF_Tree算法优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UF-Tree-Weighted"><span class="toc-number">4.8.0.2.</span> <span class="toc-text">
          UF_Tree_Weighted</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.8.0.2.1.</span> <span class="toc-text">
          路径压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.8.1.</span> <span class="toc-text">
          畅通工程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">4.9.</span> <span class="toc-text">
          图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.9.1.</span> <span class="toc-text">
          无向图的相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.9.2.</span> <span class="toc-text">
          图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">
          邻接矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">
          邻接表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">4.9.3.</span> <span class="toc-text">
          图的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.9.3.1.</span> <span class="toc-text">
          深度优先搜索</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.9.3.2.</span> <span class="toc-text">
          广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD1"><span class="toc-number">4.9.4.</span> <span class="toc-text">
          畅通工程续1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE"><span class="toc-number">4.9.5.</span> <span class="toc-text">
          路径查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.9.6.</span> <span class="toc-text">
          有向图的相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">4.9.7.</span> <span class="toc-text">
          拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E7%8E%AF"><span class="toc-number">4.9.7.1.</span> <span class="toc-text">
          检测有向图的环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%9A%84%E9%A1%B6%E7%82%B9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.9.7.2.</span> <span class="toc-text">
          基于深度优先的顶点排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.7.2.1.</span> <span class="toc-text">
          顶点排序的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">4.9.8.</span> <span class="toc-text">
          加权无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">4.9.9.</span> <span class="toc-text">
          最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%AE%9A%E4%B9%89%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BA%A6%E5%AE%9A"><span class="toc-number">4.9.9.1.</span> <span class="toc-text">
          最小生成树定义及相关约定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8E%9F%E7%90%86"><span class="toc-number">4.9.9.2.</span> <span class="toc-text">
          最小生成树原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.9.9.2.1.</span> <span class="toc-text">
          树的性质</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E5%88%86%E5%AE%9A%E7%90%86"><span class="toc-number">4.9.9.3.</span> <span class="toc-text">
          切分定理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">4.9.9.4.</span> <span class="toc-text">
          贪心算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">4.9.9.5.</span> <span class="toc-text">
          Prim算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.9.9.5.1.</span> <span class="toc-text">
          Prim算法的实现原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">4.9.9.6.</span> <span class="toc-text">
          Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.9.9.6.1.</span> <span class="toc-text">
          Kruskal算法的实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">4.9.10.</span> <span class="toc-text">
          加权有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">4.9.10.1.</span> <span class="toc-text">
          最短路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%BE%E5%BC%9B%E6%8A%80%E6%9C%AF"><span class="toc-number">4.9.10.2.</span> <span class="toc-text">
          松弛技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dijstra%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.10.3.</span> <span class="toc-text">
          Dijstra算法实现</span></a></li></ol></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/touxiang.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">“不管什么问题，都必然存在着答案”</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>supeBam</span></div><div class="busuanzi"></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>